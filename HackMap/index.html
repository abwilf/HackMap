<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="https://d3js.org/d3-path.v1.min.js"></script>
<script src="https://d3js.org/d3-selection.v1.min.js"></script>
<script src="https://d3js.org/d3-shape.v1.min.js"></script>
</head>
<body>
<script>

var svgContainer = d3.select("body").append("svg")
                                    .attr("width", $(document).width())
                                    .attr("height", $(document).height());

window.addEventListener("keydown", keyPressed, false);

 // returns 0 if n (comes from) is pressed, 1 if 'e' is pressed, 2 if r, 3 if d, 4 if delete, -1 else
function keyPressed(e) {
	console.log(e.keyCode);
    switch (e.keyCode) {
    		case 78:
    			// 0
		     console.log("The 'n' key is pressed.");

         //Fetch the node corresponding to the currently selected svg element
         temp = d3.select(currentNode).attr("id");
         selected = arr_map["" + temp];
         var txt = prompt("Enter new node text.", "Lorem Ipsum");
		     add(selected, new Node(root.x, 0, txt));
         update(root);

		     return 0;

    		case 69:
    			// 1
		     console.log("The 'e' key is pressed.");
		     //context.clearRect(0, 0, $(document).width(), $(document).height());

         //Fetch the node corresponding to the currently selected svg element
         temp = d3.select(currentNode).attr("id");
         selected = arr_map["" + temp];
         var txt = prompt("Enter new node text.", selected.data);
         selected.data = txt;

         update(root);

		     return 1;
    		case 82:
	           console.log("The 'r' key is pressed.");
	           return 2;
    		case 68:
			console.log("The 'd' key is pressed.");
			return 3;
		case 8:
			console.log("The 'delete' key is pressed.");
			return 4;
    		default:
    			console.log("Pressed an unrecognized key!");
    			return -1;
    }
}


//Constructor for Nodes
function Node(x, y, data){
    this.x = x;
    this.y = y;

    this.data = data;

    this.depth = null;
    this.parent = null;

    this.children = [];

    this.toggle = 0;
}


function saveToJSON(node_in) {
	var obj = JSONHelper(root, "");
	console.log(obj);
	// write to JSON
}
// call with root
function JSONHelper(node_in, string) {
	// loop through root and children, call this on each

  temp = node_in.parent;
  node_in.parent = null;
  temparr = node_in.children;
  node_in.children = null;

	// write string to JSON
  string += JSON.stringify(node_in);

  node_in.parent = temp;
  node_in.children = temparr;

  if (!(typeof node_in.children != "undefined" && node_in.children != null && node_in.children.length > 0)) {
		return string;
	}

	for (i = 0; i < node_in.children.length; ++i) {
    //console.log(i);
    //console.log(node_in.children[i]);
    //console.log(JSONHelper(node_in.children[i], ""));
		string += JSONHelper(node_in.children[i], "");	// recursive call
	}

	return string;
}

//Helper function, iterates through tree and calls d on each node
function traverseAndDo(node, d){

    temp = traverseAndDo;

    d(node);
    traverseAndDo = function(node){
      d(node);
      if (node.children){
        node.children.forEach(traverseAndDo);
      }
    }
    if (node.children){
      node.children.forEach(traverseAndDo);
    }

    traverseAndDo = temp;
}

//Helper function, iterates through tree and calls d on each node AFTER children
function postTraverseAndDo(node, d){

  temp = postTraverseAndDo;

  postTraverseAndDo = function(node){
    if (node.children) {
      node.children.forEach(postTraverseAndDo);
    }
    d(node);
  }
  if (node.children) {
    node.children.forEach(postTraverseAndDo);
  }
  d(node);

  postTraverseAndDo = temp;
}

//Given a node pointer, attach a node to it
function add(parent, child){
    child.parent = parent;
    parent.children.push(child);
    child.depth = parent.depth + 1;
}

//TODO
function remove(node){

      for (var i = 0; i < node.parent.children.length; i++) {
          if (node.parent.children[i] === node) {
              node.parent.children.splice(i, 1);
            return;
          }
      }
      // TODO: update
}


id = 0;
var arr_map = new Array();
function drawNode(node){

	  if (node.children) {
      for (var i = 0; i < node.children.length; ++i) {
	    var line = svgContainer.append("line")
	    					   .attr("x1", node.x-10)
	    					   .attr("y1", node.y-5)
	    					   .attr("x2", node.children[i].x-10)
	    					   .attr("y2", node.children[i].y-5)
	    					   .attr("stroke-width", 2)
	    					   .attr("stroke", "black");
	  }
	}

    var circle = svgContainer.append("circle")
                             .attr("cx", node.x - 10)
                             .attr("cy", node.y - 5)
                             .attr("r", 5)
                             .attr("fill", "white")
                             .attr("stroke", "black")
                             .attr("stroke-width", 1)
                             .attr("id", id);

    arr_map["" + id] = node;


    var text = svgContainer.append("text")
                           .attr("x", node.x)
                           .attr("y", node.y)
                           .attr("font-family", "sans-serif")
                           .attr("font-size", "15px")
                           .attr("id", "b" + id)
                           .text( function(d) { return node.data });
/*
     var lbl = svgContainer.append("text")
                            .attr("x", node.x)
                            .attr("y", node.y + 20)
                            .attr("font-family", "sans-serif")
                            .attr("font-size", "15px")
                            .attr("id", "b" + id)
                            .text( function(d) { return node.x + ", " + node.y });

*/
    node.textsize = document.getElementById("b" + id).getComputedTextLength();
    id++;

}

//Hide/Show the subtree of the selected node
function toggleSubtree(node){
  if (node.toggle == 0){
    node._children = node.children;
    node.children = [];
    node.toggle = 1;
  }
  else{
    node.children = node._children;
    node._children = [];
    node.toggle = 0;
  }
}

//from Queue.js by Stephen Morley
function Queue(){var a=[],b=0;this.getLength=function(){return a.length-b};this.isEmpty=function(){return 0==a.length};this.enqueue=function(b){a.push(b)};this.dequeue=function(){if(0!=a.length){var c=a[b];2*++b>=a.length&&(a=a.slice(b),b=0);return c}};this.peek=function(){return 0<a.length?a[b]:void 0}};


function __calculateSubtreeWidths(node, nodeWidthFunctor){
      var sum = 0;
      if (node.children){
        //console.log("Has children: " + node.children.length);
        for (var i = 0; i < node.children.length; i++){
          //console.log("child " + i + ": has width: " + node.children[i].width);
          //console.log("child " + i + ": has subtreeWidth" + node.children[i].subtreeWidth);
          sum += Math.max(node.children[i].width, node.children[i].subtreeWidth);
        }
      }

      node.subtreeWidth = sum;
      node.width = nodeWidthFunctor(node);
      node.subtreeWidth = Math.max(node.subtreeWidth, node.width);
}

function nodeWidthFunctor(node) {
    if (node.textsize){

      return node.textsize + 20;
    }
}

function calculateSubtreeWidths(node){
  __calculateSubtreeWidths(node, nodeWidthFunctor);
}

function balance(root){

  calculateSubtreeWidths(root, nodeWidthFunctor);

  //toggling the root or its subtrees can move it around the page
  //instead we'll find the difference in position and then shift the whole
  //tree back in the end
  anchor = root.x

  function __balance__(node, start){
    _start = start

    //tree is built from the bottom up, so balance all children first
    for (var i = 0; i < node.children.length; i++){
      __balance__(node.children[i], start);
      start += node.children[i].subtreeWidth;
    }


    if (node.children.length > 1){ //balance the node between its children
      node.x = (node.children[0].x + node.children[node.children.length-1].x) /2;
      node.y = (node.depth+1) * 50;
    }
    else if (node.children.length == 1){ //place node directly above its child
      node.x = node.children[0].x
      node.y = (node.depth+1) * 50;
    }
    else{ //leaf, just place the node
      node.x = _start;
      node.y = (node.depth+1) * 50;
    }

  }

  __balance__(root, root.x - root.subtreeWidth/2);

  //Now we shift the tree so that the root remains at the same location
  diff = anchor - root.x
  traverseAndDo(root, function(node) {
    node.x = node.x + diff
  })

}


function update(root){
  arr_map = new Array();	// clear arr
  id = 0; //clear id
  svgContainer.selectAll("*").remove();

  traverseAndDo(root, drawNode);

  svgContainer.selectAll("*").remove();

  postTraverseAndDo(root, calculateSubtreeWidths);

  balance(root, root.x - root.subtreeWidth/2);

  traverseAndDo(root, drawNode);

  svgContainer.selectAll("circle")
  	.on("mouseover", function() {
  		this.style.cursor = "pointer";
  		d3.select(this).attr('fill', '#302E1C');
  	})
  	.on("mouseout", function() {
  		if (currentNode != this) {
  			d3.select(this).attr('fill', 'white');
  		}
  	})
   	 .on("click", function() {
  		if (currentNode != this) {
  			// clear last node
  			d3.select(currentNode).attr('fill', 'white');
  		}
  		currentNode = this;
  		d3.select(this).attr('fill', '#302E1C');
  	})
  	.on("dblclick", function() {
  		if (currentNode != this) {
  			// clear last node
  			d3.select(currentNode).attr('fill', 'white');
  		}
  		currentNode = this;
  		d3.select(this).attr('fill', '#302E1C');

      temp = d3.select(this).attr("id");

      console.log(arr_map["" + temp]);
  		toggleSubtree(arr_map["" + temp]);

      update(root);

  	  });

}

//set up tree with empty root node
var root = new Node($(document).width() / 2, 50, "I am Root.");

var currentNode; //Yay globals!
root.depth = 0;

//calculateSubtreeWidths(root, nodeWidthFunctor);

add(root, new Node(root.x - 50, 100, "I'm a kid."));

add(root, new Node(root.x + 50, 100, "I'm a kid 2."));

add(root.children[0], new Node(root.x, 150, "I'm a Grandson."));

add(root.children[0], new Node(root.x, 200, "I'm a Granddaughter."))

add(root.children[0].children[0], new Node(root.x, 225, "I'm the map."));

add(root.children[0].children[0], new Node(root.x, 275, "I'm the map."))

add(root.children[0].children[0], new Node(root.x, 295, "I'm the map."))


add(root.children[0].children[1], new Node(root.x, 250, "I'm a Great-Grandson."));

add(root.children[0].children[1], new Node(root.x, 300, "I'm a Great-Granddaughter."))

add(root.children[1], new Node(root.x, 350, "I'm a niece."));

add(root.children[1], new Node(root.x, 400, "I'm a nephew."))

add(root.children[1].children[0], new Node(root.x, 450, "I'm a Great-niece."));

add(root.children[1].children[0], new Node(root.x, 500, "I'm a Great-nephew."));

add(root.children[1].children[1], new Node(root.x, 475, "I'm the map."));

add(root.children[1].children[1], new Node(root.x, 525, "I'm the map"));

update(root);

</script>

</body>
</html>
