<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
</head>
<body>
<script>

//Init function (e.g. main)
function start() {
  treeCanvas.start()
}

window.addEventListener("keydown", keyPressed, false);
 
 // returns 0 if n (comes from) is pressed, 1 if 'e' is pressed, 2 if r, 3 if d, 4 if delete, -1 else
function keyPressed(e) {
	console.log(e.keyCode);
    switch (e.keyCode) {
    		case 78:
    			// 0
		     console.log("The 'n' key is pressed.");
		     toggleSubtree(root);
		     context.clearRect(0, 0, $(document).width(), $(document).height());
			traverseAndDo(root, drawNode);
		     return 0;
    		case 69:
    			// 1
		     console.log("The 'e' key is pressed.");
		     context.clearRect(0, 0, $(document).width(), $(document).height());

		     return 1;
    		case 82:
	           console.log("The 'r' key is pressed.");
	           return 2;
    		case 68:
			console.log("The 'd' key is pressed.");
			return 3;
		case 8:
			console.log("The 'delete' key is pressed.");
			return 4;
    		default:
    			console.log("Pressed an unrecognized key!");
    			return -1;
    }
}


//Constructor for Nodes
function Node(x, y, data){
    this.x = x;
    this.y = y;

    this.data = data;

    this.depth = null;
    this.parent = null;

    this.children = [];
}

function saveToJSON(node_in) {
	var obj = JSONHelper(root, "");
	console.log(obj);
	// write to JSON
}
// call with root
function JSONHelper(node_in, string) {
	// loop through root and children, call this on each

  temp = node_in.parent;
  node_in.parent = null;
  temparr = node_in.children;
  node_in.children = null;

	// write string to JSON
  string += JSON.stringify(node_in);

  node_in.parent = temp;
  node_in.children = temparr;

  if (!(typeof node_in.children != "undefined" && node_in.children != null && node_in.children.length > 0)) {
		return string;
	}

	for (i = 0; i < node_in.children.length; ++i) {
    //console.log(i);
    //console.log(node_in.children[i]);
    //console.log(JSONHelper(node_in.children[i], ""));
		string += JSONHelper(node_in.children[i], "");	// recursive call
	}

	return string;
}

//Helper function, iterates through tree and calls d on each node
function traverseAndDo(node, d){
    d(node);
    traverseAndDo = function(node){
      d(node);
      node.children.forEach(traverseAndDo);
    }
    node.children.forEach(traverseAndDo);
}

//Given a node pointer, attach a node to it
function add(parent, child){
    child.parent = parent;
    parent.children.push(child);
    child.depth = parent.depth + 1;
}

//TODO
function remove(node){

      for (var i = 0; i < node.parent.children.length; i++) {
          if (node.parent.children[i] === node) {
              node.parent.children.splice(i, 1);
            return;
          }
      }
      // TODO: update
}

function drawNode(node){

  context = treeCanvas.getContext()
  context.fillText(node.data, node.x, node.y)

    for (var i = 0; i < node.children.length; ++i) {
		context.beginPath();
		context.moveTo(node.x-10,node.y-5);
		context.lineTo(node.children[i].x-10,node.children[i].y-5);
		context.stroke();
	}
	context.beginPath();
	context.arc(node.x - 10,node.y - 5,5,0,2*Math.PI);
	context.stroke();
}

//Hide/Show the subtree of the selected node
function toggleSubtree(node){
  if(node.children == null){
  	console.log("Hid Array");
    node._children = node.children;
    node.children = null;
  }
  else{
  	console.log("Reveal Array");
    node.children = node._children;
    node._children = null;
  }
}

//Creates a canvas for drawing
var treeCanvas = {
    canvas : document.createElement("canvas"),

    start : function() {

        this.canvas.width = $(document).width();
        this.canvas.height = $(document).height();

        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.context.font = "15px Arial";


    },

    getContext : function() {
        return this.context
    }
}

//from Queue.js by Stephen Morley
function Queue(){var a=[],b=0;this.getLength=function(){return a.length-b};this.isEmpty=function(){return 0==a.length};this.enqueue=function(b){a.push(b)};this.dequeue=function(){if(0!=a.length){var c=a[b];2*++b>=a.length&&(a=a.slice(b),b=0);return c}};this.peek=function(){return 0<a.length?a[b]:void 0}};

//balances the tree
function balance(d){
  var q = new Queue();
  var currLevel = 0;

  var temp = null;

  currLevel.enqueue(d);

  while (currLevel.getLength() > 0) {
    var temp = currLevel.dequeue();

    temp.children.forEach(nextLevel.enqueue);
  }
}

//set up tree with empty root node
var root = new Node($(document).width() / 2, 50, "I'm Root.");
root.depth = 0;

treeCanvas.start();

drawNode(root);

add(root, new Node(root.x - 50, 100, "I'm a kid."));

add(root, new Node(root.x + 50, 100, "I'm a kid 2."));

add(root.children[0], new Node(root.x, 150, "I'm a Grandkid."));

traverseAndDo(root, drawNode);

saveToJSON(root);

</script>

</body>
</html>
